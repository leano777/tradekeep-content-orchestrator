const fs = require('fs');\nconst path = require('path');\nconst cloudStorage = require('./cloudStorage');\nconst { PrismaClient } = require('@prisma/client');\n\nconst prisma = new PrismaClient();\n\nclass ContentIndexIntegration {\n  constructor() {\n    this.contentIndexPath = path.join(__dirname, '../../content-index.json');\n    this.contentIndex = null;\n  }\n\n  // Load the existing content index\n  async loadContentIndex() {\n    try {\n      if (fs.existsSync(this.contentIndexPath)) {\n        const indexData = fs.readFileSync(this.contentIndexPath, 'utf8');\n        this.contentIndex = JSON.parse(indexData);\n        return this.contentIndex;\n      }\n    } catch (error) {\n      console.error('Failed to load content index:', error);\n    }\n    return null;\n  }\n\n  // Get local assets from the content index\n  async getLocalAssets(options = {}) {\n    if (!this.contentIndex) {\n      await this.loadContentIndex();\n    }\n\n    if (!this.contentIndex) {\n      return [];\n    }\n\n    const allAssets = [];\n    \n    // Extract assets from different categories\n    Object.keys(this.contentIndex.content).forEach(category => {\n      this.contentIndex.content[category].forEach(item => {\n        if (this.isAssetFile(item.fileName)) {\n          allAssets.push({\n            id: `local-${item.id}`,\n            name: item.fileName,\n            path: item.path,\n            relativePath: item.relativePath,\n            type: this.getFileTypeFromExtension(item.extension),\n            category: item.category,\n            size: item.sizeBytes || 0,\n            sizeFormatted: item.size,\n            modifiedAt: item.modifiedFull || item.modified,\n            provider: 'local',\n            isLocal: true,\n            extension: item.extension,\n            title: item.title\n          });\n        }\n      });\n    });\n\n    // Apply filters\n    let filteredAssets = allAssets;\n    \n    if (options.category) {\n      filteredAssets = filteredAssets.filter(asset => asset.category === options.category);\n    }\n    \n    if (options.type) {\n      filteredAssets = filteredAssets.filter(asset => asset.type === options.type);\n    }\n    \n    if (options.search) {\n      const searchLower = options.search.toLowerCase();\n      filteredAssets = filteredAssets.filter(asset => \n        asset.name.toLowerCase().includes(searchLower) ||\n        asset.title.toLowerCase().includes(searchLower)\n      );\n    }\n    \n    if (options.fileTypes && options.fileTypes.length > 0) {\n      filteredAssets = filteredAssets.filter(asset => \n        options.fileTypes.some(type => asset.extension.toLowerCase().includes(type.toLowerCase()))\n      );\n    }\n\n    // Sort by modification date (newest first)\n    filteredAssets.sort((a, b) => new Date(b.modifiedAt) - new Date(a.modifiedAt));\n    \n    // Apply pagination\n    const start = ((options.page || 1) - 1) * (options.limit || 50);\n    const end = start + (options.limit || 50);\n    \n    return {\n      assets: filteredAssets.slice(start, end),\n      total: filteredAssets.length,\n      page: options.page || 1,\n      totalPages: Math.ceil(filteredAssets.length / (options.limit || 50))\n    };\n  }\n\n  // Get unified assets from both local and cloud sources\n  async getUnifiedAssets(userId, options = {}) {\n    const results = {\n      local: [],\n      cloud: [],\n      combined: []\n    };\n\n    try {\n      // Get local assets from content index\n      const localResult = await this.getLocalAssets(options);\n      results.local = localResult.assets;\n\n      // Initialize cloud storage for the user\n      await this.initializeUserCloudStorage(userId);\n      \n      // Get cloud assets\n      const cloudAssets = await cloudStorage.searchFiles(options.search || '', {\n        fileTypes: options.fileTypes,\n        pageSize: options.limit || 50\n      });\n      results.cloud = cloudAssets;\n\n      // Combine and sort all assets\n      results.combined = [...results.local, ...results.cloud]\n        .sort((a, b) => new Date(b.modifiedAt) - new Date(a.modifiedAt));\n\n      // Apply final pagination to combined results\n      const start = ((options.page || 1) - 1) * (options.limit || 50);\n      const end = start + (options.limit || 50);\n      results.combined = results.combined.slice(start, end);\n\n    } catch (error) {\n      console.error('Error getting unified assets:', error);\n    }\n\n    return results;\n  }\n\n  // Search across all asset sources\n  async searchAllAssets(userId, query, options = {}) {\n    const searchOptions = {\n      ...options,\n      search: query\n    };\n    \n    return await this.getUnifiedAssets(userId, searchOptions);\n  }\n\n  // Get asset statistics\n  async getAssetStatistics(userId) {\n    try {\n      const [localResult, cloudAssets] = await Promise.all([\n        this.getLocalAssets(),\n        this.getUnifiedAssets(userId, { limit: 1000 }) // Get a large sample for stats\n      ]);\n\n      const localCount = localResult.total || 0;\n      const cloudCount = cloudAssets.cloud.length;\n      \n      // Calculate storage saved (estimate)\n      const localSize = localResult.assets.reduce((sum, asset) => sum + asset.size, 0);\n      const storageSaved = this.formatFileSize(localSize);\n\n      // Get category breakdown from local assets\n      const categoryBreakdown = {};\n      localResult.assets.forEach(asset => {\n        categoryBreakdown[asset.category] = (categoryBreakdown[asset.category] || 0) + 1;\n      });\n\n      // Get type breakdown\n      const typeBreakdown = {};\n      [...localResult.assets, ...cloudAssets.cloud].forEach(asset => {\n        typeBreakdown[asset.type] = (typeBreakdown[asset.type] || 0) + 1;\n      });\n\n      return {\n        local: {\n          count: localCount,\n          size: localSize,\n          sizeFormatted: storageSaved\n        },\n        cloud: {\n          count: cloudCount\n        },\n        total: {\n          count: localCount + cloudCount\n        },\n        categories: categoryBreakdown,\n        types: typeBreakdown,\n        storageSaved\n      };\n    } catch (error) {\n      console.error('Error getting asset statistics:', error);\n      return {\n        local: { count: 0, size: 0, sizeFormatted: '0 Bytes' },\n        cloud: { count: 0 },\n        total: { count: 0 },\n        categories: {},\n        types: {},\n        storageSaved: '0 Bytes'\n      };\n    }\n  }\n\n  // Utility methods\n  isAssetFile(fileName) {\n    const assetExtensions = [\n      '.jpg', '.jpeg', '.png', '.webp', '.gif', '.svg', // Images\n      '.mp4', '.mov', '.avi', '.mkv', '.webm', // Videos\n      '.mp3', '.wav', '.ogg', // Audio\n      '.pdf', '.doc', '.docx', '.ppt', '.pptx', // Documents\n      '.zip', '.rar', '.7z', // Archives\n      '.ai', '.psd', '.sketch', '.fig' // Design files\n    ];\n    \n    const extension = path.extname(fileName).toLowerCase();\n    return assetExtensions.includes(extension);\n  }\n\n  getFileTypeFromExtension(extension) {\n    if (!extension) return 'file';\n    \n    const ext = extension.toLowerCase();\n    \n    if (['.jpg', '.jpeg', '.png', '.webp', '.gif', '.svg'].includes(ext)) return 'image';\n    if (['.mp4', '.mov', '.avi', '.mkv', '.webm'].includes(ext)) return 'video';\n    if (['.mp3', '.wav', '.ogg'].includes(ext)) return 'audio';\n    if (['.pdf'].includes(ext)) return 'pdf';\n    if (['.doc', '.docx'].includes(ext)) return 'document';\n    if (['.ppt', '.pptx'].includes(ext)) return 'presentation';\n    if (['.xls', '.xlsx'].includes(ext)) return 'spreadsheet';\n    if (['.ai', '.psd', '.sketch', '.fig'].includes(ext)) return 'design';\n    \n    return 'file';\n  }\n\n  formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  async initializeUserCloudStorage(userId) {\n    const preferences = await prisma.userPreference.findMany({\n      where: {\n        userId,\n        key: {\n          in: ['googledrive_tokens', 'onedrive_tokens']\n        }\n      }\n    });\n    \n    for (const pref of preferences) {\n      if (pref.key === 'googledrive_tokens') {\n        await cloudStorage.initializeGoogleDrive(pref.value);\n      }\n      if (pref.key === 'onedrive_tokens') {\n        await cloudStorage.initializeOneDrive(pref.value.access_token);\n      }\n    }\n  }\n\n  // Refresh the content index\n  async refreshContentIndex() {\n    try {\n      // Run the content indexer script\n      const { exec } = require('child_process');\n      const indexerPath = path.join(__dirname, '../../../content-indexer.js');\n      \n      return new Promise((resolve, reject) => {\n        exec(`node \"${indexerPath}\"`, (error, stdout, stderr) => {\n          if (error) {\n            console.error('Failed to refresh content index:', error);\n            reject(error);\n          } else {\n            console.log('Content index refreshed successfully');\n            // Reload the index\n            this.loadContentIndex();\n            resolve(stdout);\n          }\n        });\n      });\n    } catch (error) {\n      console.error('Error refreshing content index:', error);\n      throw error;\n    }\n  }\n}\n\nmodule.exports = new ContentIndexIntegration();"